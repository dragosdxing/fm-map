<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>FM Map Romania & Moldova</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
html,body{margin:0;padding:0;}
#map{height:100vh;width:100vw;}

#radioPanel{
    position:absolute;
    top:10px;
    left:60px;
    background:white;
    padding:10px;
    border-radius:10px;
    box-shadow:0 3px 12px rgba(0,0,0,0.35);
    z-index:1000;
    font-family:Arial;
}

#freqInput{
    width:70px;
    text-align:center;
    font-size:16px;
}

button{
    margin:2px;
    padding:4px 8px;
    cursor:pointer;
    border-radius:6px;
    border:1px solid #aaa;
    background:#f5f5f5;
}
button:hover{ background:#eaeaea; }
</style>
</head>

<body>

<div id="radioPanel">
<b>FM Tuner</b><br>

Frequency:<br>
<button onclick="stepDown()">−</button>
<input id="freqInput" type="text" value="97.9">
<button onclick="stepUp()">+</button>

<br><br>
Country:<br>
<button onclick="setCountry('ro')">Romania</button>
<button onclick="setCountry('md')">Moldova</button>
</div>

<div id="map"></div>

<script>

/* ================= MAP ================= */

var map = L.map('map').setView([47.2, 26.5], 7);

L.tileLayer(
'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
{ maxZoom:19 }
).addTo(map);

L.tileLayer(
'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
{ maxZoom:19, opacity:0.85 }
).addTo(map);

/* ================= ICONS ================= */

var antennaIcon = L.icon({
    iconUrl: 'https://i.ibb.co/Bh7GDMv/antenna.png',
    iconSize: [24,24],
    iconAnchor: [12,24],
    popupAnchor: [0,-22]
});

var receiverIcon = L.icon({
    iconUrl: 'https://i.ibb.co/Z2w2XK6/yagi.png',
    iconSize: [30,30],
    iconAnchor: [15,30]
});

let receiverMarker = null;
let distanceLine = null;

/* ================= DATA ================= */

let allStationsRO = [];
let allStationsMD = [];
let currentCountry = "ro";
let geoLayer = null;
let dataLoaded = false;

Promise.all([
    fetch('fm.json').then(r=>r.json()),
    fetch('fm_md.json').then(r=>r.json())
]).then(([ro,md])=>{
    allStationsRO = ro.features;
    allStationsMD = md.features;
    dataLoaded = true;
    tune();
});

/* ================= CONTROLS ================= */

function setCountry(c){
    currentCountry = c;
    tune();
}

function stepUp(){
    let f = parseFloat(freqInput.value)||97.9;
    f = Math.min(108,(f+0.1));
    freqInput.value = f.toFixed(1);
    tune();
}

function stepDown(){
    let f = parseFloat(freqInput.value)||97.9;
    f = Math.max(87.5,(f-0.1));
    freqInput.value = f.toFixed(1);
    tune();
}

document.getElementById("freqInput").addEventListener("keydown",function(e){
    if(e.key==="Enter") tune();
});

/* ================= RECEIVER ================= */

map.on('contextmenu', function(e){

    if(receiverMarker){
        map.removeLayer(receiverMarker);
    }

    receiverMarker = L.marker(e.latlng,{
        icon:receiverIcon,
        draggable:true
    }).addTo(map)
    .bindPopup("<b>Receiver position</b>")
    .openPopup();

    receiverMarker.on("drag", function(){
        if(distanceLine){
            map.removeLayer(distanceLine);
        }
    });
});

/* ================= CALCULATIONS ================= */

function toRad(x){ return x*Math.PI/180; }
function toDeg(x){ return x*180/Math.PI; }

function haversine(lat1, lon1, lat2, lon2){
    let R = 6371;
    let dLat = toRad(lat2-lat1);
    let dLon = toRad(lon2-lon1);

    let a =
        Math.sin(dLat/2)**2 +
        Math.cos(toRad(lat1))*Math.cos(toRad(lat2)) *
        Math.sin(dLon/2)**2;

    let c = 2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    return R*c;
}

function calculateAzimuth(lat1, lon1, lat2, lon2){

    let dLon = toRad(lon2-lon1);

    let y = Math.sin(dLon) * Math.cos(toRad(lat2));
    let x =
        Math.cos(toRad(lat1))*Math.sin(toRad(lat2)) -
        Math.sin(toRad(lat1))*Math.cos(toRad(lat2))*Math.cos(dLon);

    let brng = toDeg(Math.atan2(y,x));
    return (brng+360)%360;
}

/* estimare simplă rază ERP */
function estimateRange(desc){

    let m = desc.match(/(\d+)\s*kW/i);
    if(!m) return null;

    let erp = parseFloat(m[1]);

    // model aproximativ: 20km pentru 1kW, ~√ERP scaling
    return (20 * Math.sqrt(erp)).toFixed(1);
}

/* ================= TUNER ================= */

function normalizeFreq(text){
    return parseFloat(text.replace(",","."));
}

function extractFrequencies(desc){
    let matches = desc.match(/\b(8[7-9][\.,]\d|9\d[\.,]\d|10[0-8][\.,]\d)\b/g);
    if(!matches) return [];
    return matches.map(f => normalizeFreq(f));
}

function tune(){

    if(!dataLoaded) return;

    let freq = parseFloat(document.getElementById("freqInput").value);

    if(geoLayer) map.removeLayer(geoLayer);

    let dataset = (currentCountry==="ro") ? allStationsRO : allStationsMD;

    let filteredFeatures = [];

    dataset.forEach(f => {

        let desc = f.properties.description || "";
        let freqs = extractFrequencies(desc);

        let found = freqs.some(stationFreq =>
            Math.abs(stationFreq - freq) < 0.051
        );

        if(found){
            filteredFeatures.push(f);
        }
    });

    geoLayer = L.geoJSON({
        type:"FeatureCollection",
        features: filteredFeatures
    },{
        pointToLayer: function(feature, latlng){
            return L.marker(latlng,{icon:antennaIcon});
        },
        onEachFeature: function(feature, layer){

            layer.on('contextmenu', function(){

                if(!receiverMarker){
                    alert("Place receiver first (right click on map).");
                    return;
                }

                let r = receiverMarker.getLatLng();
                let txLat = feature.geometry.coordinates[1];
                let txLng = feature.geometry.coordinates[0];

                let d = haversine(r.lat,r.lng,txLat,txLng);
                let az = calculateAzimuth(r.lat,r.lng,txLat,txLng);
                let range = estimateRange(feature.properties.description);

                if(distanceLine){
                    map.removeLayer(distanceLine);
                }

                distanceLine = L.polyline([
                    [r.lat,r.lng],
                    [txLat,txLng]
                ],{color:'lime',weight:2}).addTo(map);

                layer.bindPopup(
                    "<b>"+feature.properties.name+"</b><br>"+
                    "Distance: <b>"+d.toFixed(2)+" km</b><br>"+
                    "Azimuth: <b>"+az.toFixed(1)+"°</b><br>"+
                    (range ? "Estimated range: <b>"+range+" km</b>" : "")
                ).openPopup();
            });

            layer.bindPopup(
                "<b>"+(feature.properties.name||"")+"</b><br>"+
                feature.properties.description
            );
        }
    }).addTo(map);
}

</script>
</body>
</html>
