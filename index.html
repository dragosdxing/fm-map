<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>FM Map Romania & Moldova</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
html,body{margin:0;padding:0;}
#map{height:100vh;width:100vw;}

#radioPanel{
    position:absolute;
    top:10px;
    left:60px;
    background:white;
    padding:8px 10px;
    border-radius:8px;
    box-shadow:0 2px 8px rgba(0,0,0,0.3);
    z-index:1000;
    font-family:Arial;
    font-size:14px;
}

#radioPanel input{ width:70px; }

.countryBtn{ margin-top:4px; }
</style>
</head>

<body>

<div id="radioPanel">
<b>FM Tuner</b><br>
Frequency:
<input id="freqInput" type="number" step="0.1" min="87.5" max="108" value="97.9">

<br><br>
Country:<br>
<button class="countryBtn" onclick="setCountry('ro')">Romania</button>
<button class="countryBtn" onclick="setCountry('md')">Moldova</button>
</div>

<div id="map"></div>

<script>

/* ================= MAP ================= */

var map = L.map('map').setView([46.1, 26.5], 7);

L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',{
    maxZoom:19
}).addTo(map);

L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',{
    maxZoom:19
}).addTo(map);

/* ================= ICONS ================= */

var txIcon = L.icon({
    iconUrl:'https://i.ibb.co/Bh7GDMv/antenna.png',
    iconSize:[26,26],
    iconAnchor:[13,26],
    popupAnchor:[0,-26]
});

var receiverIcon = L.icon({
    iconUrl:'https://i.ibb.co/MkmK51LJ/yagi.png',
    iconSize:[34,34],
    iconAnchor:[17,34],
    popupAnchor:[0,-30]
});

/* ================= GLOBALS ================= */

let geoLayer=null;
let allStations=[];
let currentCountry="ro";
let receiverMarker=null;
let distanceLine=null;

/* ================= DISTANCE FORMAT ================= */

function formatDistance(km){

    if(km < 1){
        return Math.round(km*1000) + " m";
    }else{
        return Math.round(km) + " km";
    }
}

/* ================= LOAD DATA ================= */

function loadStations(country){

    let file = country==="ro" ? "fm.json" : "fm_md.json";

    fetch(file)
    .then(r=>r.json())
    .then(data=>{
        allStations=data.features;
        tune();
    });
}

loadStations("ro");

/* ================= TUNE ================= */

function tune(){

    if(!allStations.length) return;

    let freq=parseFloat(document.getElementById("freqInput").value);

    if(geoLayer) map.removeLayer(geoLayer);

    let filtered=[];

    allStations.forEach(f=>{

        let desc=f.properties.description||"";

        let stations=desc.split(/(?=\d{2,3}[\.,]\d\s*[hv]?)/gi);

        let matched=stations.filter(s=>{
            let m=s.match(/\d{2,3}[\.,]\d/);
            if(!m) return false;
            return Math.abs(parseFloat(m[0].replace(",","."))-freq)<0.05;
        });

        if(matched.length>0){

            let newF=JSON.parse(JSON.stringify(f));
            newF.properties.description=matched.join("<br>");
            filtered.push(newF);
        }
    });

    geoLayer=L.geoJSON({
        type:"FeatureCollection",
        features:filtered
    },{
        pointToLayer:function(feature,latlng){
            return L.marker(latlng,{icon:txIcon});
        },

        onEachFeature:function(feature,layer){

            let desc=feature.properties.description||"";
            desc=desc.replace(/(\d{2,3}[\.,]\d)/g,"<br>$1");

            layer.bindPopup(
                "<b>"+(feature.properties.name||"")+"</b><br>"+desc
            );

            layer.on("contextmenu",function(e){

                if(!receiverMarker) return;

                if(distanceLine) map.removeLayer(distanceLine);

                let p1=receiverMarker.getLatLng();
                let p2=e.latlng;

                distanceLine=L.polyline([p1,p2],{color:"yellow"}).addTo(map);

                let distKm=map.distance(p1,p2)/1000;
                let dist=formatDistance(distKm);

                let azimuth=bearing(p1,p2);

                layer.bindPopup(
                    "<b>"+(feature.properties.name||"")+"</b><br>"+
                    desc+
                    "<hr>"+
                    "Distance: "+dist+"<br>"+
                    "Beam: "+azimuth.toFixed(0)+"Â°"
                ).openPopup();
            });
        }
    }).addTo(map);
}

/* ================= COUNTRY SWITCH ================= */

function setCountry(c){
    currentCountry=c;
    loadStations(c);
}

/* ================= AUTO TUNE ================= */

document.getElementById("freqInput").addEventListener("input",tune);
document.getElementById("freqInput").addEventListener("keyup",e=>{
    if(e.key==="Enter") tune();
});

/* ================= RECEIVER ================= */

map.on("contextmenu",function(e){

    if(e.originalEvent.target.closest(".leaflet-marker-icon")) return;

    if(receiverMarker){
        map.removeLayer(receiverMarker);
        receiverMarker=null;
    }

    if(distanceLine){
        map.removeLayer(distanceLine);
        distanceLine=null;
    }

    receiverMarker=L.marker(e.latlng,{
        icon:receiverIcon,
        draggable:true
    }).addTo(map)
    .bindPopup("<b>Receiver position</b><br>(right click to remove)")
    .openPopup();

    receiverMarker.on("drag",()=>{
        if(distanceLine){
            map.removeLayer(distanceLine);
            distanceLine=null;
        }
    });

    receiverMarker.on("contextmenu",()=>{
        map.removeLayer(receiverMarker);
        receiverMarker=null;

        if(distanceLine){
            map.removeLayer(distanceLine);
            distanceLine=null;
        }
    });
});

/* ================= BEARING ================= */

function bearing(a,b){

    let lat1=a.lat*Math.PI/180;
    let lat2=b.lat*Math.PI/180;
    let dLon=(b.lng-a.lng)*Math.PI/180;

    let y=Math.sin(dLon)*Math.cos(lat2);
    let x=Math.cos(lat1)*Math.sin(lat2)-Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);

    let brng=Math.atan2(y,x)*180/Math.PI;
    return (brng+360)%360;
}

</script>
</body>
</html>
