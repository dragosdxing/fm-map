<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="utf-8"/>
<title>FM Map Romania & Moldova</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
html, body { margin:0; padding:0; background: #000; }
#map { height:100vh; width:100vw; }

/* ================= DARK MODE PANOU CONTROL ================= */
#radioPanel {
    position: absolute;
    top: 10px;
    left: 60px;
    background: #222;
    color: #eee;
    padding: 14px 18px;
    border-radius: 8px;
    border: 1px solid #444;
    box-shadow: 0 4px 15px rgba(0,0,0,0.8);
    z-index: 1000;
    font-family: Arial, sans-serif;
    font-size: 14px;
}

#radioPanel input { 
    width: 65px; 
    text-align: center;
    font-weight: bold;
    background: #111;
    color: #00ff00;
    border: 1px solid #555;
    padding: 4px;
    border-radius: 4px;
    font-size: 15px;
}

#radioPanel input::-webkit-outer-spin-button,
#radioPanel input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}
#radioPanel input[type=number] { -moz-appearance: textfield; }

.tune-btn {
    width: 30px;
    height: 30px;
    font-weight: bold;
    cursor: pointer;
    background: #333;
    color: #fff;
    border: 1px solid #555;
    border-radius: 4px;
    font-size: 16px;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
}
.tune-btn:hover { background: #444; }

.countryBtn { 
    margin-top: 6px; 
    cursor: pointer;
    padding: 6px 12px;
    border: 1px solid #555;
    background: #333;
    color: #ccc;
    border-radius: 4px;
    font-weight: bold;
    transition: all 0.2s;
}
.countryBtn:hover { background: #444; }
.countryBtn.active {
    background: #00ff00;
    color: #111;
    border-color: #00cc00;
}

/* ================= STILIZARE RDS TIP RADIO ================= */
.rds-box {
    display: inline-block;
    background: #111;
    color: #00ff00;
    font-family: 'Courier New', Courier, monospace;
    padding: 2px 6px;
    border-radius: 3px;
    font-weight: bold;
    letter-spacing: 2px;
    min-width: 95px;
    text-align: center;
    box-shadow: inset 0 0 5px rgba(0,255,0,0.4);
}

/* ================= DARK MODE LEAFLET POPUPS (SEMI-TRANSPARENT) ================= */
.leaflet-popup-content-wrapper {
    background: rgba(25, 25, 25, 0.85); /* 85% opacitate pentru a vedea harta/receptorul */
    backdrop-filter: blur(4px); /* Efect modern de sticlÄƒ matÄƒ */
    -webkit-backdrop-filter: blur(4px);
    color: #eee;
    border: 1px solid #444;
    box-shadow: 0 3px 14px rgba(0,0,0,0.8);
    border-radius: 6px;
}
.leaflet-popup-tip {
    background: rgba(25, 25, 25, 0.85);
    border-top: 1px solid #444;
    border-left: 1px solid #444;
}
.leaflet-popup-content { margin: 14px; line-height: 1.5; }
.leaflet-container a.leaflet-popup-close-button { color: #aaa; }
.leaflet-container a.leaflet-popup-close-button:hover { color: #fff; }
hr { border: 0; border-top: 1px solid #555; margin: 10px 0; }
.leaflet-popup-content a { color: #00ff00; }
</style>
</head>

<body>

<div id="radioPanel">
    <div style="margin-bottom: 10px; font-size: 16px;"><b>ðŸ“» FM Tuner</b></div>
    
    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 15px;">
        <button class="tune-btn" onclick="stepFreq(-0.1)">-</button>
        <input id="freqInput" type="number" step="0.1" min="87.5" max="108" value="97.9">
        <button class="tune-btn" onclick="stepFreq(0.1)">+</button>
    </div>
    
    <div style="font-size: 12px; margin-bottom: 4px; color: #aaa;">Country / Database:</div>
    <button id="btn-ro" class="countryBtn active" onclick="setCountry('ro')">Romania</button>
    <button id="btn-md" class="countryBtn" onclick="setCountry('md')">Moldova</button>
</div>

<div id="map"></div>

<script>
/* ================= MAP ================= */
var map = L.map('map').setView([46.1, 26.5], 7);

L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',{
    maxZoom: 19
}).addTo(map);

L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',{
    maxZoom: 19
}).addTo(map);

/* ================= ICONS ================= */
var txIcon = L.icon({
    iconUrl: 'https://i.ibb.co/Bh7GDMv/antenna.png',
    iconSize: [26, 26],
    iconAnchor: [13, 26],
    popupAnchor: [0, -26]
});

var receiverIcon = L.icon({
    iconUrl: 'https://i.ibb.co/MkmK51LJ/yagi.png',
    iconSize: [34, 34],
    iconAnchor: [17, 34],
    popupAnchor: [0, -30]
});

/* ================= GLOBALS ================= */
let geoLayer = null;
let allStations = [];
let currentCountry = "ro";
let receiverMarker = null;
let distanceLine = null;

function formatDistance(km){
    if(km < 1) return Math.round(km * 1000) + " m";
    return Math.round(km) + " km";
}

async function getLocationName(lat, lon){
    try {
        let url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=12&addressdetails=1`;
        let r = await fetch(url, { headers: { "Accept": "application/json" } });
        let data = await r.json();
        let a = data.address;
        return (a.city || a.town || a.village || a.municipality || a.county || "Unknown location");
    } catch {
        return "Unknown location";
    }
}

/* ================= LOAD DATA ================= */
function loadStations(country){
    let file = country === "ro" ? "fm.json" : "fm_md.json";

    fetch(file)
    .then(r => r.json())
    .then(data => {
        allStations = data.features;
        tune();
    })
    .catch(err => console.error("Eroare la Ã®ncÄƒrcarea fiÈ™ierului JSON:", err));
}

loadStations("ro"); 

/* ================= TUNE & PARSE ================= */
function tune(){
    if(!allStations.length) return;

    let freq = parseFloat(document.getElementById("freqInput").value);
    if(geoLayer) map.removeLayer(geoLayer);

    let filtered = [];
    let regexFM = /\b(?:8[7-9]|9\d|10[0-8])[\.,]\d+\b/;

    allStations.forEach(f => {
        let desc = f.properties.description || "";
        let stations = desc.split(/(?=\b(?:8[7-9]|9\d|10[0-8])[\.,]\d+\b)/gi);

        let matched = stations.filter(s => {
            let m = s.match(regexFM);
            if(!m) return false;
            let fVal = parseFloat(m[0].replace(",", "."));
            return Math.abs(fVal - freq) <= 0.05;
        });

        if(matched.length > 0){
            let newF = JSON.parse(JSON.stringify(f));
            
            let formatted = matched.map(s => {
                let s2 = s.replace(regexFM, "<b style='color:#00ff00;'>$&</b>"); 
                
                s2 = s2.replace(/(W|kW|w|kw)\s*((?:\[[^\]]+\]\s*)+)(\s*\([^)]+\))?$/, function(match, powerStr, rdsBlocks, extraText) {
                    extraText = extraText || "";
                    let frames = rdsBlocks.match(/\[([^\]]+)\]/g).map(frame => frame.slice(1, -1));
                    let safeFrames = encodeURIComponent(JSON.stringify(frames));
                    return powerStr + ` <span class="rds-box" data-frames="${safeFrames}" data-idx="0">[${frames[0]}]</span>` + extraText;
                });

                return s2;
            });

            newF.properties.description = formatted.join("<br><hr>");
            filtered.push(newF);
        }
    });

    geoLayer = L.geoJSON({
        type: "FeatureCollection",
        features: filtered
    }, {
        pointToLayer: function(feature, latlng){
            return L.marker(latlng, {icon: txIcon});
        },
        onEachFeature: function(feature, layer){
            let desc = feature.properties.description || "";
            let name = feature.properties.name || "Unknown Transmitter";

            layer.bindPopup(`<b style="font-size:15px;">${name}</b><br><hr>${desc}`);

            layer.on("contextmenu", function(e){
                if(!receiverMarker) return;
                if(distanceLine) map.removeLayer(distanceLine);

                let p1 = receiverMarker.getLatLng();
                let p2 = e.latlng;

                distanceLine = L.polyline([p1, p2], {color: "#00ff00", weight: 3, dashArray: "5, 5"}).addTo(map);

                let distKm = map.distance(p1, p2) / 1000;
                let dist = formatDistance(distKm);
                let azimuth = bearing(p1, p2);

                // DezactivÄƒm autoPan-ul standard al ferestrei ca sÄƒ-l putem controla noi mai inteligent
                layer.bindPopup(
                    `<b style="font-size:15px;">${name}</b><br><hr>${desc}` +
                    `<hr><div style="color:#aaa;"><b>Distance:</b> <span style="color:#00ff00;">${dist}</span><br>` +
                    `<b>Beam:</b> <span style="color:#00ff00;">${azimuth.toFixed(0)}Â°</span></div>`,
                    { autoPan: false } 
                ).openPopup();

                // SMART AUTO-FIT: ÃŽncadrÄƒm automat ambele puncte, forÈ›Ã¢nd spaÈ›iu Ã®n partea de sus pentru fereastrÄƒ
                map.flyToBounds(distanceLine.getBounds(), {
                    paddingTopLeft: [50, 180], // LÄƒsÄƒm 180px liberi sus pentru a nu acoperi pop-up-ul
                    paddingBottomRight: [50, 50],
                    maxZoom: 14 // Facem zoom suficient Ã®ncÃ¢t sÄƒ se separe receptorul de emiÈ›Äƒtor dacÄƒ sunt prea aproape
                });
            });
        }
    }).addTo(map);
}

/* ================= RDS ANIMATION SCRIPT ================= */
setInterval(() => {
    document.querySelectorAll('.rds-box').forEach(box => {
        let framesAttr = box.getAttribute('data-frames');
        if (framesAttr) {
            let frames = JSON.parse(decodeURIComponent(framesAttr));
            if (frames.length > 1) {
                let idx = parseInt(box.getAttribute('data-idx'));
                idx = (idx + 1) % frames.length; 
                box.setAttribute('data-idx', idx);
                box.innerText = `[${frames[idx]}]`;
            }
        }
    });
}, 2500);

/* ================= AUTO TUNE CONTROLS ================= */
function stepFreq(delta) {
    let input = document.getElementById("freqInput");
    let val = parseFloat(input.value) + delta;
    if(val < 87.5) val = 108.0;
    if(val > 108.0) val = 87.5;
    input.value = val.toFixed(1);
    tune();
}

document.getElementById("freqInput").addEventListener("input", tune);
document.getElementById("freqInput").addEventListener("keyup", e => {
    if(e.key === "Enter") tune();
});

/* ================= COUNTRY SWITCH ================= */
function setCountry(c){
    currentCountry = c;
    document.getElementById("btn-ro").classList.toggle("active", c === "ro");
    document.getElementById("btn-md").classList.toggle("active", c === "md");
    loadStations(c);
}

/* ================= RECEIVER & BEARING ================= */
map.on("contextmenu", function(e){
    if(e.originalEvent.target.closest(".leaflet-marker-icon")) return;

    if(receiverMarker){ map.removeLayer(receiverMarker); receiverMarker = null; }
    if(distanceLine){ map.removeLayer(distanceLine); distanceLine = null; }

    receiverMarker = L.marker(e.latlng, { icon: receiverIcon, draggable: true }).addTo(map);
    receiverMarker.bindPopup("<b>Searching location...</b>").openPopup();

    getLocationName(e.latlng.lat, e.latlng.lng).then(name => {
        receiverMarker.setPopupContent(`<b>${name}</b><br>(right click to remove)`);
    });

    receiverMarker.on("drag", () => {
        if(distanceLine){ map.removeLayer(distanceLine); distanceLine = null; }
    });

    receiverMarker.on("dragend", () => {
        let p = receiverMarker.getLatLng();
        receiverMarker.setPopupContent("<b>Searching location...</b>");
        getLocationName(p.lat, p.lng).then(name => {
            receiverMarker.setPopupContent(`<b>${name}</b><br>(right click to remove)`);
        });
    });

    receiverMarker.on("contextmenu", () => {
        map.removeLayer(receiverMarker); receiverMarker = null;
        if(distanceLine){ map.removeLayer(distanceLine); distanceLine = null; }
    });
});

function bearing(a, b){
    let lat1 = a.lat * Math.PI / 180;
    let lat2 = b.lat * Math.PI / 180;
    let dLon = (b.lng - a.lng) * Math.PI / 180;
    let y = Math.sin(dLon) * Math.cos(lat2);
    let x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    let brng = Math.atan2(y, x) * 180 / Math.PI;
    return (brng + 360) % 360;
}
</script>
</body>
</html>
